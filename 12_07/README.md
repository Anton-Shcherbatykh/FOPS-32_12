# Домашнее задание к занятию «Репликация и масштабирование. Часть 2» (Щербатых А.Е.)
## Задание 1
Опишите основные преимущества использования масштабирования методами:

- активный master-сервер и пассивный репликационный slave-сервер;
- master-сервер и несколько slave-серверов;

*Дайте ответ в свободной форме.*

## Ответ

**Активный Master-сервер и пассивный репликационный Slave-сервер**

Архитектура:

``` text
┌─────────────┐    ┌─────────────┐
│   MASTER    │───▶│   SLAVE     │
│  (Active)   │    │ (Passive)   │
│ Read/Write  │    │ Read Only   │
└─────────────┘    └─────────────┘
```
Основные преимущества:

### А. Отказоустойчивость и восстановление

**Резервное копирование в реальном времени**: Slave постоянно синхронизирован с Master 

**Быстрое восстановление**: При падении Master можно быстро переключиться на Slave

**Тестирование обновлений**: На Slave можно тестировать обновления БД без риска для production

### Б. Распределение нагрузки

**Оффлоад бэкапов**: Резервное копирование выполняется на Slave, не нагружая Master

**Аналитические запросы**: Тяжелые отчеты и аналитика выполняются на Slave

### В. Безопасность и разработка

**Изоляция данных**: Разработчики могут работать со Slave без риска повреждения production-данных

**Географическое распределение**: Slave может находиться в другом ЦОД для защиты от сбоев

**Master-сервер и несколько Slave-серверов**

Архитектура:

``` text
              ┌─────────────┐
              │   MASTER    │
              │  (Active)   │
              │ Read/Write  │
              └─────────────┘
                     │
    ┌────────────────┼────────────────┐
    │                │                │
┌───────┐        ┌───────┐        ┌───────┐
│SLAVE 1│        │SLAVE 2│        │SLAVE 3│
│(Read) │        │(Read) │        │(Read) │
└───────┘        └───────┘        └───────┘
```
Основные преимущества:
### А. Масштабирование чтения ###

**Распределение нагрузки**: Запросы на чтение распределяются между несколькими Slave

**Высокая доступность**: При падении одного Slave другие продолжают работать

**Линейное масштабирование**: Можно добавлять Slave для увеличения производительности чтения

### Б. Географическое распределение ###

**Локализация данных**: Slave могут находиться в разных регионах для уменьшения задержек

**Отказоустойчивость**: Сбой в одном дата-центре не остановит работу системы

### В. Специализация серверов ###

**Slave для отчетности**: Выделенный сервер для тяжелых аналитических запросов

**Slave для кэширования**: Сервер для часто запрашиваемых данных

**Slave для разработки**: Отдельный сервер для тестирования

## Задание 2
Разработайте план для выполнения горизонтального и вертикального шаринга базы данных. База данных состоит из трёх таблиц:

- пользователи,
- книги,
- магазины (столбцы произвольно)
  
Опишите принципы построения системы и их разграничение или разбивку между базами данных.

*Пришлите блоксхему, где и что будет располагаться. Опишите, в каких режимах будут работать сервера.*

### Архитектура системы
**Горизонтальный шардинг (по данным)**
Принцип: Разделение данных одной таблицы между разными серверами по ключу шардинга

**Вертикальный шардинг (по функционалу)**
Принцип: Разделение таблиц между разными серверами по функциональному назначению

### Схема разбивки данных
``` text
┌─────────────────────────────────────────────────────────────┐
│                    ШАРДИНГ СИСТЕМА                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ВЕРТИКАЛЬНЫЙ ШАРДИНГ (по типу данных)                      │
│  ┌─────────────────┐  ┌─────────────────┐  ┌───────────────┐│
│  │  ШАРД USERS     │  │  ШАРД BOOKS     │  │ ШАРД STORES   ││
│  │  (Пользователи) │  │  (Книги)        │  │ (Магазины)    ││
│  └─────────────────┘  └─────────────────┘  └───────────────┘│
│                                                             │
│  ГОРИЗОНТАЛЬНЫЙ ШАРДИНГ (внутри каждого вертикального шарда)│
│  ┌──────┐ ┌──────┐   ┌──────┐ ┌──────┐    ┌──────┐ ┌──────┐ │
│  │USR_S1│ │USR_S2│   │BK_S1 │ │BK_S2 │    │ST_S1 │ │ST_S2 │ │
│  └──────┘ └──────┘   └──────┘ └──────┘    └──────┘ └──────┘ │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Детальный план реализации
1. Вертикальный шардинг - разделение по таблицам
   
**Шард USERS (Сервер 1):**

``` sql
-- Таблица пользователей
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY,
    email VARCHAR(255),
    name VARCHAR(100),
    registration_date DATETIME,
    country_code VARCHAR(3)
) sharding_key = user_id;
```
**Шард BOOKS (Сервер 2):**
``` sql
-- Таблица книг
CREATE TABLE books (
    book_id BIGINT PRIMARY KEY,
    title VARCHAR(500),
    author VARCHAR(200),
    genre VARCHAR(50),
    price DECIMAL(10,2),
    publisher_id BIGINT
) sharding_key = book_id;

-- Таблица инвентаря (принадлежит к книгам)
CREATE TABLE inventory (
    inventory_id BIGINT,
    book_id BIGINT,
    store_id BIGINT,
    quantity INT
) sharding_key = book_id;
```
**Шард STORES (Сервер 3):**
``` sql
-- Таблица магазинов
CREATE TABLE stores (
    store_id BIGINT PRIMARY KEY,
    name VARCHAR(200),
    location VARCHAR(300),
    manager_id BIGINT,
    country_code VARCHAR(3)
) sharding_key = store_id;
```
**Горизонтальный шардинг - правила распределения**
**Для пользователей (USERS):**

- Ключ шардинга: ``` text user_id ```

- Количество шардов: 4

- Правило: ``` text user_id % 4 ```

- Шард USR_S1: user_id % 4 = 0

- Шард USR_S2: user_id % 4 = 1

- Шард USR_S3: user_id % 4 = 2

- Шард USR_S4: user_id % 4 = 3

**Для книг (BOOKS):**

- Ключ шардинга:  ``` text book_id  ```

- Количество шардов: 8

- Правило:  ``` text book_id % 8  ```

- Распределение по 8 серверам (как пример, чтобы не расписывать все - ``` Шард BK_S1: user_id % 1 = 0 ```)

**Для магазинов (STORES):**

- Ключ шардинга:  ``` text store_id  ```

- Количество шардов: 2

- Правило:  ``` text store_id % 2  ```

- Шард ST_S1: store_id % 2 = 0

- Шард ST_S2: store_id % 2 = 1

### Режимы работы серверов

**Конфигурация репликации**
```
┌────────────────┐    ┌────────────────┐
│   MASTER       │    │    SLAVE       │
│   (Read/Write) │◄──►│   (Read Only)  │
└────────────────┘    └────────────────┘
      ▲                      ▲
      │                      │
      └───── Load Balancer ──┘
```

Каждый шард работает в режиме Master-Slave:

- Master: Принимает запросы на запись (INSERT, UPDATE, DELETE)

- Slave: Принимает запросы на чтение (SELECT) - несколько реплик

**Координатор шардинга**

``` bash
class ShardingCoordinator:
    def get_shard_connection(self, table_name, shard_key):
        if table_name == "users":
            shard_num = shard_key % 4
            return f"user_shard_{shard_num}"
        
        elif table_name == "books":
            shard_num = shard_key % 8
            return f"book_shard_{shard_num}"
            
        elif table_name == "stores":
            shard_num = shard_key % 2
            return f"store_shard_{shard_num}"
```

**Преимущества архитектуры**

Масштабируемость: Каждый тип данных масштабируется независимо

Производительность: Распределение нагрузки чтения/записи

Отказоустойчивость: Репликация каждого шарда

Гибкость: Можно добавлять шарды для конкретных таблиц

**Недостатки и решения**

Сложные JOIN: Требуют межшардовых запросов

Транзакции: Ограниченная поддержка распределенных транзакций

Миграция данных: Требует специальных инструментов
